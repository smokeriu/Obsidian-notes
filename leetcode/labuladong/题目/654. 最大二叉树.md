# 链接
#### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)
# 题目
给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
- 创建一个根节点，其值为 nums 中的最大值。
- 递归地在最大值 左边 的 子数组前缀上 构建左子树。
- 递归地在最大值 右边 的 子数组后缀上 构建右子树。
返回 nums 构建的 最大二叉树 。
# 思路
## 思路1
1. 由于题目是二叉树，我们比较容易想到通过二叉树的递归，来构造子树。
### 代码
```java
class Solution {  
    public TreeNode constructMaximumBinaryTree(int[] nums) {  
        return find(nums, 0, nums.length - 1);  
    }  
  
    public TreeNode find(int[] nums, int left, int right) {  
        if (left > right) {  
            return null;  
        }  
        // find max index  
        int idx = left;  
        for (int i = left; i <= right; i++) {  
            if (nums[i] > nums[idx]) {  
                idx = i;  
            }  
        }  
        final TreeNode root = new TreeNode(nums[idx]);  
        root.left = find(nums, left, idx - 1);  
        root.right = find(nums, idx + 1, right);  
        return root;  
    }  
}
```
### 注意
1. 注意数组可能越界的问题。
## 思路2
1. 思路1最大的问题是，数组会被遍历N次，在最坏的情况下，数组是单调的。
2. 由于我们的目的，就是找到节点A左右的最大值的坐标，并以此递归下去，所以我们可以考虑使用单调栈的思路。
### 代码
```java

```