KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

# 前缀表

KMP的核心是next数组，next数组就是一个前缀表（prefix table）。**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**


其核心是：
记录下标i之前（包括i）的字符串中，有**多大长度**的相同前缀后缀。
- 前缀：**指不包含最后一个字符的所有以第一个字符开头的连续子串**。
- 后缀：**指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。



举一个例子：要在文本串：aab*aabaaf*a 中查找是否出现过一个模式串：*aabaaf*。可以看出，文本串中第六个字符`b` （*aabaa*baafa）和 模式串的第六个字符`f`（*aabaa*f），不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中**第三个字符b**（aa**b**aabaafa）继续开始匹配。

因为匹配的过程在下标5的地方遇到不匹配，模式串是指向f：
![[Pasted image 20241227093720.png]]
利用前缀表，可以找到了下标2，指向b，继续匹配：
![[Pasted image 20241227093742.png]]
因为，下标5之前这部分的字符串（也就是字符串*aabaa*）的最长相等的前缀 和 后缀字符串是 子字符串*aa* ，因为找到了**最长相等的前缀和后缀**，匹配*失败的位置是后缀子串的后面*，那么我们找到*与其相同的前缀的后面*重新匹配就可以了。

# 如何计算前缀表

> next数组其实就是前缀表。

以`aabaaf`为例，随着指针从左向右移动，其前后缀长度表如下表所示：

| 字符串   | 长度  | 前后缀 |
| ----- | --- | --- |
| a     | 0   |     |
| aa    | 1   | a   |
| aab   | 0   |     |
| aaba  | 1   | a   |
| aabaa | 2   | aa  |
匹配逻辑如下动画所示：

![[KMP精讲2.gif]]

这里由于后缀和前缀相同的特性，可知`aa`在文本串中已经被匹配，所以这个前缀的重新匹配可以省略。

# 构建前缀表

在构建前缀表时，一般喜欢在上述文章的基础上，统一减一（右移一位，初始位置为-1）。其匹配动画如下图所示：

![[KMP精讲4.gif]]

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况