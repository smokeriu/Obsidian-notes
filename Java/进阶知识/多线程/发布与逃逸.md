发布，即该对象能够在当前作用域之外的代码中使用到，即通过Getter方法，使其他代码能够获取到对象Field的引用。

# 避免逃逸

## this逃逸

在多线程场景下，一个比较麻烦的场景是this引用的逃逸（逸出）。

```java
public class ThisEscape{
	public ThisEscape(Event e){
		e.register(
			new Listener(){
				public void onI(I i){
					doSomething();
				}
			}
		)
	}

	public void doSomething();
}
```

造成这种错误最常见的情况是：
- 在构造函数中**启动**了一个线程。

这会导致，在构建函数创建完之前，其他线程就已经可以看到他了。
比较合适的方法时 通过一个open方法来启动线程

## 线程封闭
当一个对象是线程封闭的，那他就不必考虑溢出的问题。
### AD-hoc
即依靠程序实现来实现线程封闭，一般不建议使用。
### 栈封闭
在方法中定义的局部变量，具有较好的线程封闭特性。
- 对于基本类型，则一定是线程安全的。因为没有任何方法能够获得基本类型的引用。所以可以将其作为方法返回，这不会破坏其封闭的特性。
- 对于引用类型，则需要封闭在方法中，一旦作为返回值移除，则其将丢失线程安全的特性。
	- 变量在方法内仍然是线程安全的。
### ThreadLocal
使用ThreadLocal类，可以将变量封闭在一个线程类。每个线程通过`ThreadLocal.get()`获取到的对象，都封闭在线程类。

## 不变性
不可变的对象一定是安全的，其需要满足下述条件：
1. 对象创建成功后期状态就不能修改。
2. 对象所有域都是Final的。
	1. 或者所有域都是线程安全的、或者事实不变的。
3. 对象是正确被创建的。（没有this逃逸）


# 如何发布
## 不安全的发布

### 正确的对象被破坏
```java
public Holder holder;
public void init(){
	holder = new Holder(1);
}
```
上述代码中，holder变量是public的，但其初始化时通过`init`方法完成的，这就可能导致其他线程看到还未初始化完成的holder，我们想象holder是如此初始化的：
```java
public class Holder{
	private int n;
	public Holder(int n ) { this.n = n; }
	public void assertSan(){
		if ( n!= n ){
			throw ...
		}
	}
}
```
Holder本身没有问题，但如果被不正确的发布，则线程调用assertSan方法时，在进行if判断