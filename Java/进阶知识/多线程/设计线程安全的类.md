设计一个线程安全的类，主要包括如下：
- 找出构成对象状态的所有变量。
- 找出约束状态变量的不变性条件。
- 建立并发访问管理策略。

# 收集同步需求
收集同步需求，一般指的是通过分析类的变量，来判断各种操作是否是线程安全的。

## 变量
一个对象的变量包括了其所有的字段，如果这些字段不是基础类型的，则含包括了内部的字段。并以此不断递归。
不过一般情况下，大部分字段都是集合类，我们自己构建的类，基础类型，某些库提供的类。当库提供的类过于复杂而难以分析时，我们可以将其整个看成非线程安全的。

## 不变性条件
某些变量自身受到其他约束、或对其改变依赖于之前的值（先验条件）、或其改变后的值收到了某些限制（后验条件），这就说明这个变量有不变性条件。对于这类变量进行修改时，需要注意原子性。

## 状态所有权
有时我们需要发布变量，如果需要保证线程安全，则需要参考[[发布与逃逸]]来确保是正确发布的。

# 并发访问策略
## 实例封闭
将所有数据限制在一个实例内部，仅通过有限的方法对外提供服务，这样，所有访问路径都是已知的，就更容易保证线程安全性。
一般而言，会结合加锁策略来保证线程安全性。

> 这个策略下，无论变量自身是否线程安全，都可以通过合适的加锁策略来保证整个类是线程安全的。

### 监视器模式
上述策略其实就是监视器模式，其含义是：
将所有**可变**对象都封装起来，并有对象自己的**内置锁**保护。
```java
class PrivateLock{
	private final Object myLock = new Object();
	@GuardedBy("myLock") int i;

	void doSomething(){
		synchronized(myLock){
			// doSomething on i;
		}
	}
}
```
注意：
- myLock需要时非静态的，因为其是**对象**的内置锁。
- myLock需要伴随对象一起初始化。
- `@GuardedBy`只是一个注解约定，用来告诉阅读者这个变量被哪个锁保护。


## 线程安全委托
如果所有变量都是线程安全的，那么由其组成的类不一定是线程安全的。这是由于一个操作可以同时修改多个变量，而这些变量可能受不变性条件影响。

> 即使不受不变性条件影响，在多线程下修改，也会导致程序出现不可预知的结果。例如非线程安全的方法A可以同时设置`(x,y)`，线程A和线程B同时调用方法时，可能导致最终的`(x,y)`结果与两个线程的预期都不同。
> 如果(x,y)之间有不变性条件影响，则可能导致更加严重的后果。

## 