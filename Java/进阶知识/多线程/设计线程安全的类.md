设计一个线程安全的类，主要包括如下：
- 找出构成对象状态的所有变量。
- 找出约束状态变量的不变性条件。
- 建立并发访问管理策略。

# 收集同步需求
收集同步需求，一般指的是通过分析类的变量，来判断各种操作是否是线程安全的。

## 变量
一个对象的变量包括了其所有的字段，如果这些字段不是基础类型的，则含包括了内部的字段。并以此不断递归。
不过一般情况下，大部分字段都是集合类，我们自己构建的类，基础类型，某些库提供的类。当库提供的类过于复杂而难以分析时，我们可以将其整个看成非线程安全的。

## 不变性条件
某些变量自身受到其他约束、或对其改变依赖于之前的值（先验条件）、或其改变后的值收到了某些限制（后验条件），这就说明这个变量有不变性条件。对于这类变量进行修改时，需要注意原子性。

## 状态所有权
有时我们需要发布变量，如果需要保证线程安全，则需要参考[[发布与逃逸]]来确保是正确发布的。

# 并发访问策略
## 实例封闭
将所有数据限制在一个实例内部，仅通过有限的方法对外提供服务，这样，所有访问路径都是已知的，就更容易保证线程安全性。
一般而言，会结合加锁策略来保证线程安全性。

> 这个策略下，无论变量自身是否线程安全，都可以通过合适的加锁策略来保证整个类是线程安全的。

### 监视器模式
上述策略其实就是监视器模式，其含义是：
将所有**可变**对象都封装起来，并有对象自己的**内置锁**保护。
```java
class PrivateLock{
	private final Object myLock = new Object();
	@GuardedBy("myLock") int i;

	void doSomething(){
		synchronized(myLock){
			// doSomething on i;
		}
	}
}
```
注意：
- myLock需要时非静态的，因为其是**对象**的内置锁。
- myLock需要伴随对象一起初始化。
- `@GuardedBy`只是一个注解约定，用来告诉阅读者这个变量被哪个锁保护。

> 上例代码中，由于int是非线程安全的，对其的操作都需要在锁下进行。而不能委托给其自身。

## 线程安全委托
如果所有变量都是线程安全的，那么由其组成的类不一定是线程安全的。这是由于一个操作可以同时修改多个变量，而这些变量可能受不变性条件影响。

> 即使不受不变性条件影响，在多线程下修改，也会导致程序出现不可预知的结果。例如非线程安全的方法A可以同时设置`(x,y)`，线程A和线程B同时调用方法时，可能导致最终的`(x,y)`结果与两个线程的预期都不同。
> 如果(x,y)之间有不变性条件影响，则可能导致更加严重的后果。

一般而言，由于变量自身是线程安全的，我们关注的重点可以进行缩小：
- 保证多个变量同时变更的原子性。
	- 如果一个方法会同时修改多个变量的状态，即使这些变量自身是线程安全的，也需要通过加锁等手段保证线程安全性。
- 线程安全的变量的状态是否被不变性条件约束。
	- 如果一个状态被某些不变性条件约束，那么需要通过锁来保证其是线程安全的，否则则可以放心的交给变量自身。
- 注意被发布的变量。
	- 如果一个状态变量是线程安全的，并且不被任何不变性条件约束，对其的操作也不存在任何不允许的状态转换，那么可以安全的发布这个变量。

```java
class A {
	private final AtomicLong i1;
	// left must < right;
	private final AtomicLong left;
	private final AtomicLong right;
}
```
上例中：
- `i1`没有不变性条件约束，且自身是线程安全的，对其的单独修改可以放心的委托给其自身。
- `left`和`right`有不变性约束，即使其自身是线程安全的，也不能委托给其自身。
	- 我们更新right前，需要检查修改后的值是否仍然符合不变性约束。
- `i1`没有不变性条件约束，所以可以放心发布。而`left`和`right`有不变性约束，不能被发布。

## 为线程安全的类添加方法
主要有如下方法：
1. 继承。
2. 客户端加锁。
3. 组合。
### 继承
继承的问题在于发布时，使用者可能无法知道具体的类型。

### 客户端加锁
即类似于组合，不过将变量发布，在添加其他方法操作变量，不过添加方法时可能出现错误：
```java
public class ListHolder{
	public List<String> threadSafeList;

	// method
}
```


