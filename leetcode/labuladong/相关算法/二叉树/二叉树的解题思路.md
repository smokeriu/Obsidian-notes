# 解构二叉树
## 拆分成子树
一般二叉树的题目，先考虑其能否拆分成对子树的处理。一个典型的题目就是[226. 翻转二叉树](226.%20翻转二叉树.md)。题目本身没啥难度，不过由于我们需要获取修改后的根节点，所以需要使用[二叉树的后序遍历](二叉树的后序遍历.md)的方式。

对于能够将逻辑拆分成子树的情况，一般都会使用递归。在题目[114. 二叉树展开为链表](114.%20二叉树展开为链表.md)中，还设计对子树结果进行额外处理以满足题目要求。

## 通过层序遍历解题
如果题目无法拆分成子树，一般意味着需要通过层序遍历来解决。就如同题目[116. 填充每个节点的下一个右侧节点指针](116.%20填充每个节点的下一个右侧节点指针.md)一样。

# 构造二叉树
## 先构造子树
通过递归，先构造子树，递归出栈时，即为父数的左节点或右节点。典型题目就是[654. 最大二叉树](654.%20最大二叉树.md)。
不过有些时候，构建二叉树可能是[二叉树的遍历](二叉树的遍历.md)的反向操作，我们需要熟悉3种遍历思路，整理特点。一般而言，我们无法单独通过一种遍历生成的数组来反向完成二叉树的构建，但任意两种组合就可以反推回去。典型题目就是：[105. 从前序与中序遍历序列构造二叉树](105.%20从前序与中序遍历序列构造二叉树.md)和[106. 从中序与后序遍历序列构造二叉树](106.%20从中序与后序遍历序列构造二叉树.md)和[889. 根据前序和后序遍历构造二叉树](889.%20根据前序和后序遍历构造二叉树.md)。
> 这类题目有个关键点在于二叉树中没有重复元素。