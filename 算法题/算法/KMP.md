KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

# 前缀表

KMP的核心是next数组，next数组就是一个前缀表（prefix table）。**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**


其核心是：
记录下标i之前（包括i）的字符串中，有**多大长度**的相同前缀后缀。
- 前缀：**指不包含最后一个字符的所有以第一个字符开头的连续子串**。
- 后缀：**指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。



举一个例子：要在文本串：aab*aabaaf*a 中查找是否出现过一个模式串：*aabaaf*。可以看出，文本串中第六个字符`b` （*aabaa*baafa）和 模式串的第六个字符`f`（*aabaa*f），不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中**第三个字符b**（aa**b**aabaafa）继续开始匹配。

因为匹配的过程在下标5的地方遇到不匹配，模式串是指向f：
![[Pasted image 20241227093720.png]]
利用前缀表，可以找到了下标2，指向b，继续匹配：
![[Pasted image 20241227093742.png]]
因为，下标5之前这部分的字符串（也就是字符串*aabaa*）的最长相等的前缀 和 后缀字符串是 子字符串*aa* ，因为找到了**最长相等的前缀和后缀**，匹配*失败的位置是后缀子串的后面*，那么我们找到*与其相同的前缀的后面*重新匹配就可以了。

# 如何计算前缀表

> next数组其实就是前缀表。

以`aabaaf`为例，随着指针从左向右移动，其前后缀长度表如下表所示：

| 字符串   | 长度  | 前后缀 |
| ----- | --- | --- |
| a     | 0   |     |
| aa    | 1   | a   |
| aab   | 0   |     |
| aaba  | 1   | a   |
| aabaa | 2   | aa  |
匹配逻辑如下动画所示：

![[KMP精讲2.gif]]

这里由于后缀和前缀相同的特性，可知`aa`在文本串中已经被匹配，所以这个前缀的重新匹配可以省略。

# 构建前缀表

在构建前缀表时，一般喜欢在上述文章的基础上，统一减一（右移一位，初始位置为-1）。其匹配动画如下图所示：

![[KMP精讲4.gif]]

**构造next数组其实就是计算模式串t，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

## 初始化

定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：

```java
int j = -1;
next[0] = j;
```

`next[i]` 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）。另外，因为j初始化为-1，那么i就从1开始，进行`s[i]` 与 `s[j+1]`的比较。所以遍历模式串s的循环下标i 要从 1开始，代码如下：
```java
for (int i = 1; i < s.size(); i++) {}
```

## 处理前后缀不相同的情况

如果 `s[i]` 与 `s[j+1]`不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。就要找 `j+1`前一个元素在next数组里的值（就是`next[j]`）。


```java
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```
## 处理前后缀相同的情况

如果 `s[i]` 与 `s[j + 1]` 相同，说明找到了相同的前后缀，那么就同时向后移动`i` 和`j` ，同时还要将`j`（前缀的长度）赋给`next[i]`, 因为`next[i]`要记录相同前后缀的长度。

```java
for(int i = 1; i < s.size(); i++) { // 注意i从1开始
    while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
        j = next[j]; // 向前回退
    }
    if (s[i] == s[j + 1]) { // 找到相同的前后缀
        j++;
    }
    next[i] = j; // 将j（前缀的长度）赋给next[i]
}
```

其动画如图所示：
![[KMP精讲3.gif]]

# 使用前缀表来匹配

> 模式串：匹配字典。
> 文本串：待匹配字符串。

定义两个下标`j`指向模式串起始位置，`i`指向文本串起始位置。其中`j`的初始值为`-1`，这是因为设计前缀表时的值时`-1`。接下来就是 `s[i]` 与 `t[j + 1]` （因为j从-1开始的） 进行比较。

- 如果 `s[i]` 与 `t[j + 1]` 不相同，j就要从next数组里寻找下一个匹配的位置。


# 参考

- [代码随想录](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)