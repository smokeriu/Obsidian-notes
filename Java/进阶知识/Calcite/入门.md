初次使用Calcite，需要如下行为：
1. 将Calcite依赖加入。
2. 编写自己的`ftl`文件和相关类。
3. 提取Calcite的`Parser.jj`模版。
4. 使用fmpp插件完成打包。

# 加入依赖
向maven中加入对应的依赖：
```xml
<dependency>  
    <groupId>org.apache.calcite</groupId>  
    <artifactId>calcite-core</artifactId>  
    <version>${calcite.version}</version>  
</dependency>
```
# 编写拓展代码
> 这里主要介绍拓展SQL语法。

拓展SQL语法需要类继承自`SqlCall`。这里以一个DDL语句为例，用于创建一个view。
## 类
拓展一个语法，我们需要实现SqlNode，一般需要实现SqlCall。一些其他的明确类型的语法，也可以集成其他子类，如SqlAlter：

```java
public class CreateMaterializedView  
        extends SqlCall {
    // 标记这个操作的类型
    public static final SqlSpecialOperator CREATE_MATERIALIZED_VIEW = new SqlSpecialOperator("CREATE_MATERIALIZED_VIEW", SqlKind.OTHER_DDL);  

    // 操作
    SqlIdentifier viewName;  
    boolean existenceCheck;  
    SqlSelect query;  

	// 第一个参数是固定写法
    public CreateMaterializedView(SqlParserPos pos, SqlIdentifier viewName, boolean existenceCheck, SqlSelect query) {  
        super(pos);  
        this.viewName = viewName;  
        this.existenceCheck = existenceCheck;  
        this.query = query;  
    }  

	// 
    @Override  
    public SqlOperator getOperator() {  
        return CREATE_MATERIALIZED_VIEW;  
    }  
  
    @Override  
    public List<SqlNode> getOperandList() {  
        List<SqlNode> operands = new ArrayList<>();  
        operands.add(viewName);  
        operands.add(SqlLiteral.createBoolean(existenceCheck, SqlParserPos.ZERO));  
        operands.add(query);  
        return operands;  
    }  
  
    @Override  
    public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {  
        writer.keyword("CREATE MATERIALIZED VIEW");  
        if (existenceCheck) {  
            writer.keyword("IF NOT EXISTS");  
        }  
        viewName.unparse(writer, leftPrec, rightPrec);  
        writer.keyword("AS");  
        query.unparse(writer, leftPrec, rightPrec);  
    }  
}
```
上述代码中最主要的三部分：
1. SqlOperator：SqlOperator反应了SQL-tree中节点的类型，表达了SQL语句中的任意运算，如函数，操作符和语法结构。
2. OperandList：
3. unparse：
## ftl

## fmpp

# 提取Parser.jj模版