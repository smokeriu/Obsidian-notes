所谓编码器和解码器架构，主要目的是将神经网络分割开：

![[assets/Pasted image 20231008181728.png]]

- 编码器：负责将input转换为中间状态。
- 解码器：负责将中间状态和input转换为输出。
	- 这里的input一般指的是解码器输入，和编码器输入一般是不同的

这么做的好处在于，可以将编码器和解码器的实现分开，提高灵活性。

# 编码器
编码器的代码定义如下：
```python
from torch import nn

#@save
class Encoder(nn.Module):
    """编码器-解码器架构的基本编码器接口"""
    def __init__(self, **kwargs):
        super(Encoder, self).__init__(**kwargs)

    def forward(self, X, *args):
        raise NotImplementedError
```

# 解码器
解码器的代码定义如下：
```python
#@save
class Decoder(nn.Module):
    """编码器-解码器架构的基本解码器接口"""
    def __init__(self, **kwargs):
        super(Decoder, self).__init__(**kwargs)

    def init_state(self, enc_outputs, *args):
        raise NotImplementedError

    def forward(self, X, state):
        raise NotImplementedError
```
相比于编码器，解码器需要根据`enc_outputs`——编码器输出，来初始化状态。若将二者合并，则有：
```python
#@save
class EncoderDecoder(nn.Module):
    """编码器-解码器架构的基类"""
    def __init__(self, encoder, decoder, **kwargs):
        super(EncoderDecoder, self).__init__(**kwargs)
        self.encoder = encoder
        self.decoder = decoder

    def forward(self, enc_X, dec_X, *args):
	    # 编码器输出，enc_X为编码器的input。
        enc_outputs = self.encoder(enc_X, *args)
        # 解码器初始状态
        dec_state = self.decoder.init_state(enc_outputs, *args)
        # 解码器前向传播，dec_X为解码器的input
        return self.decoder(dec_X, dec_state)
```
