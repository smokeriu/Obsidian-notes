Amoro的文件扫描主要是通过`com.netease.arctic.server.optimizing.scan.TableFileScanHelper`接口定义的。其主要方法是`scan`方法。
其在接口内部定义了一个静态内部类FileScanResult，其中定义了两个字段：
- `DataFile file`。
- `List<ContentFile<?>> deleteFiles`。

其目前有两个实现，下文以`KeyedTableFileScanHelper`说明。

# KeyedTableFileScanHelper
其在内部定义了一个ChangeFiles的内部类。
## ChangeFiles
其包含了四个字段：
- `KeyedTable arcticTable`：对应的表实例。
- `Map cachedRelatedDeleteFiles`：缓存中的，属于某个DataFile的删除文件。
- `Map equalityDeleteFiles`：`eq-delete`类型的文件。
- `Map insertFiles`：`insert`类型的文件。
上述Map均是一个二层Map，第一层的key是分区partition，第二层的Key则是DataTreeNode。

> DataTreeNode可以认为是文件在树上的索引。

其中，cachedRelatedDeleteFiles稍微复杂些。

### addFile
用于向ChangeFiles中添加文件，其参数是`DataFile`类型。添加前，会通过参数获取：
- 分区信息。
- `DataTreeNode`信息。
- 类型信息。

通过判断文件的类型，将其加入到`insertFiles`或`equalityDeleteFiles`中。

```java
switch (type) {  
  case EQ_DELETE_FILE:  
    equalityDeleteFiles  
        .computeIfAbsent(partition, key -> Maps.newHashMap())  
        .computeIfAbsent(node, key -> Sets.newHashSet())  
        .add(file);  
    break;  
  case INSERT_FILE:  
    insertFiles  
        .computeIfAbsent(partition, key -> Maps.newHashMap())  
        .computeIfAbsent(node, key -> Sets.newHashSet())  
        .add(file);  
    break;
```

### getRelatedDeleteFiles
这个方法负责生成cachedRelatedDeleteFiles并返回。其参数也是`DataFile`。