
# 链接

[1247. 交换字符使得字符串相同](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/)

# 题目

有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。

每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。

交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换` s1[i]` 和 `s2[j]`，但不能交换 `s1[i]` 和 `s1[j]`。

最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。

# 思路

1. 遍历两个数组，找到所有不同的组成的子串。记为sub1, sub2。
2. 我们的目的就是通过题目的交换规则，使得sub1和sub2一致。由此可知，sub1和sub2的长度必为偶数。由于交换必为偶数，意味着我们可以将所有交换都可以拆分成两种情况：

情况1（需要交换一次）
| 1   | 2   |
| --- | --- |
| x   | x   |
| y   | y   |

或
情况2（需要交换两次）
| 1   | 2   |
| --- | --- |
| x   | y   |
| y   | x   |

3. 那我们的目的就很简单了，找到有多少个这种对子。那这种对子是否可以再度简化呢，可以。

>尽管题目说不允许字符串内部的左右交换，但如果s1的ij进行交换的同时，s2的ij也进行交换，那由于二者的相对位置没有发生改变。所以其实本质是没有交换的。
>提这么一嘴的目的，就是我们不需要关心x或y具体的坐标和左右顺序，我们的目的就是凑对子，而本质就两种情况。

那么我们只需要知道`sub1`中x有a个，y有b个就可以了。因为a/2和b/2代表着一次交换（情况1），而如果要出现情况2，则必定是落单的情况，则我们只需要检测a或b对2取余是否有余数即可。

# 代码

```java
class Solution {  
    public int minimumSwap(String s1, String s2) {  
        if (s1.length() != s2.length()) {  
            return -1;  
        }  
  
        // x in s1;  
        int diff1 = 0;  
        // y in s1;  
        int diff2 = 0;  
  
  
        for (int i = 0; i < s1.length(); i++) {  
            final char c1 = s1.charAt(i);  
            final char c2 = s2.charAt(i);  
            if (c1 != c2) {  
                if (c1 == 'x') {  
                    diff1++;  
                } else {  
                    diff2++;  
                }  
            }  
        }  
  
        if ((diff1 + diff2) % 2 != 0) {  
            return -1;  
        }  
  
        return diff1 / 2 + diff2 / 2 + (diff1 % 2) * 2;  
    }  
}
```

# Tag

