
二分查找，适合于**有序**地数组，即优先查找位于中间的值，与目标值进行匹配，由于我们的数组是有序的，我与我们可以根据大小来判断目标值应当处于当前值的左侧还是右侧，从而减少数组的遍历次数。

> 由于链表的特性，二分查找是极度不适合处理链表的。


# 核心

二分查找的核心代码很简单：

```java
int right_bound(int[] nums, int target) {
	int left = 0, right = nums.length;
	while (left < right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] == target) {
			left = mid + 1;
			
		} else if (nums[mid] < target) {
			left = mid + 1;

		} else if (nums[mid] > target) {
			right = mid;
		}
	}

	return left - 1;
}
```

# 陷阱

## While循环的退出条件

需要明确的是，二分查找的退出条件可以简单的的形容为：无内容可查找。二分查找的本质是维护一个左右双指针，并每次查看两者中间的值。所以我们设置while退出条件时，需要明确指针包含部分是否还有内容。
- 如果right的初始位置是数组的长度（即数组最后一个元素的下一个虚拟位置），此时遍历的范围是`[left, right)`，则当`left==right`时，遍历范围来到了`[right, right)`，可见区间内已经不可能容纳元素，则所有数据都已经完成了遍历。
	- 退出条件应该是`left == right`。
	- 循环条件条件应该是`while(left < right)`。
- 如果right的初始位置是数组的最后一个元素，，此时遍历的范围是`[left, right]`，则当`left==right`时，遍历范围来到了`[right, right]`，尚能容纳一个元素，故仍然尚有元素未完成遍历。
	- 退出条件应该是`left > right`。
	- 循环条件条件应该是`while(left <= right)`。
所以根据right的初始位置，while的退出条件也会有所不同。

## mid的计算

一般而言，`int mid = (left + right) / 2`，唯一需要注意的是，left+right
