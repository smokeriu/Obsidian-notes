发布，即该对象能够在当前作用域之外的代码中使用到，即通过Getter方法，使其他代码能够获取到对象Field的引用。

# 避免逃逸

## this逃逸

在多线程场景下，一个比较麻烦的场景是this引用的逃逸（逸出）。

```java
public class ThisEscape{
	public ThisEscape(Event e){
		e.register(
			new Listener(){
				public void onI(I i){
					doSomething();
				}
			}
		)
	}

	public void doSomething();
}
```

造成这种错误最常见的情况是：
- 在构造函数中**启动**了一个线程。

这会导致，在构建函数创建完之前，其他线程就已经可以看到他了。
比较合适的方法时 通过一个open方法来启动线程

## 线程封闭
当一个对象是线程封闭的，那他就不必考虑溢出的问题。
### AD-hoc
即依靠程序实现来实现线程封闭，一般不建议使用。
### 栈封闭
在方法中定义的局部变量，具有较好的线程封闭特性。
- 对于基本类型，则一定是线程安全的。因为没有任何方法能够获得基本类型的引用。所以可以将其作为方法返回，这不会破坏其封闭的特性。
- 对于引用类型，则需要封闭在方法中，一旦作为返回值移除，则其将丢失线程安全的特性。
	- 变量在方法内仍然是线程安全的。
### ThreadLocal
使用ThreadLocal类，可以将变量封闭在一个线程类。每个线程通过`ThreadLocal.get()`获取到的对象，都封闭在线程类。

## 不变性
不可变的对象一定是安全的，其需要满足下述条件：
1. 对象创建成功后期状态就不能修改。
2. 对象所有域都是Final的。
	1. 或者所有域都是线程安全的、或者事实不变的。
3. 对象是正确被创建的。（没有this逃逸）


# 如何发布
## 不安全的发布

### 正确的对象被破坏
```java
public Holder holder;
public void init(){
	holder = new Holder(1);
}
```
上述代码中，holder变量是public的，但其初始化时通过`init`方法完成的，这就可能导致其他线程看到还未初始化完成的holder，我们想象holder是如此初始化的：
```java
public class Holder{
	private int n;
	public Holder(int n ) { this.n = n; }
	public void assertSan(){
		if ( n!= n ){
			throw ...
		}
	}
}
```
Holder本身没有问题，但如果被不正确的发布，则线程调用assertSan方法时，在进行if判断时，看到的第一个n和第二个n的值可能不一样。
解决方法是：
1. 使用final修饰n。
2. 将Holder正确发布，即保证`init`方法执行完后，`holder`才对外可见。

## 安全发布
安全发布分为两种情况：
### 发布不可变对象
当一个对象满足[不变性](发布与逃逸.md#不变性)时，便可以安全的将其发布。因为其内部状态一旦发布就无法被修改。

### 发布事实不可变对象


### 发布可变对象
可变对象必须以安全的形式来发布。这意味着发布或使用该对象的线程需要使用同步机制。
#### 安全发布可变对象
如果要安全的发布可变对象，需要保证对象的状态必须**同时**对其他线程可见：
> 这里仅仅讨论发布，不讨论发布后的修改。
- 在静态初始化函数中初始化一个对象引用。
	- `public static Holder holder = new Holder(42)`。其会在JVM在**类初始化阶段**就被执行，故一定是线程安全的。
- 将对象引用保存到volatile类型的域，或者AtomicRefrance对象中。
	- volatile和AtomicRefrance都能保证**可见性**，故可以安全发布。
- 将对象的引用保存在某个正确构造的对象的final类型域中。
	- 即通过不可变对象的封装，来完成安全发布。但由于其发布后自身仍然是不可变对象，所以**使用他不是线程安全**的。
- 将对象的引用保存到一个由锁保护的域中。
	- 一般指使用线程安全的容器来发布对象，如ConcurrentMap、BlockingQueue等。一个对象一旦被线程A放入安全容器，那么可以确保线程B看到A设置的X状态。
	- 注意这里的状态需要在**放入容器前便确定**，即只能保证安全发布。
