一般而言，我们应当尽可能使用线程安全的类来处理多线程情况，但在并行环境下，比较容易犯错的一个情况是，两个线程安全的变量的操作没有放在一个原子操作内，导致的线程不安全：
```java
AtomicReference<BigInteger> lastNumber;
AtomicReference<BigInteger[]> lastFactors

service(BigInteger i){
	BigInteger[] factors = factor(i);
	lastNumber.set();
	lastFactors.set(factors);
}
```

上述代码中，尽管`lastNumber`和`lastFactors`都是线程安全的，但对于方法service而言，这两行可能被不同的线程分别同时执行，导致其存储错误的数据。对于这种情况，我们需要保证限制性`lastNumber`和后执行`lastFactors`发生在一个线程中。即这个代码块的执行应当是原子的。所以需要使用到Java的同步代码块机制：

```java
synchronized(lock){
	// code
}
```

其包含两部分：
- 作为锁的对象引用。
- 被这个锁保护的代码块。

> 另一个简单的使用方法就是用`synchronized`修饰整个方法，不过此时的锁是对象锁，意味着其他线程将无法执行该