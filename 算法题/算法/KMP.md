KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

# 前缀表

KMP的核心是next数组，next数组就是一个前缀表（prefix table）。**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**


其核心是：
**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**
- 前缀：**指不包含最后一个字符的所有以第一个字符开头的连续子串**。
- 后缀：**指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。



举一个例子：要在文本串：aab*aabaaf*a 中查找是否出现过一个模式串：*aabaaf*。可以看出，文本串中第六个字符`b` （*aabaa*baafa）和 模式串的第六个字符`f`（*aabaa*f），不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中**第三个字符b**（aa**b**aabaafa）继续开始匹配。

因为匹配的过程在下标5的地方遇到不匹配，模式串是指向f：
![[Pasted image 20241227093720.png]]
利用前缀表，可以找到了下标2，指向b，继续匹配：
![[Pasted image 20241227093742.png]]
因为，下标5之前这部分的字符串（也就是字符串*aabaa*）的最长相等的前缀 和 后缀字符串是 子字符串*aa* ，因为找到了**最长相等的前缀和后缀**，匹配*失败的位置是后缀子串的后面*，那么我们找到*与其相同的前缀的后面*重新匹配就可以了。